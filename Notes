To run just one test:
python test_goBananas.py TestGoBananas.test_position_bananas


Make some suites out of my unittests:

http://agiletesting.blogspot.com/2005/01/python-unit-testing-part-1-unittest.html

Log Files:
logs when subject collides with banana ('Yummy')
logs every time gets a reward ('Beep')
logs when reward is over and banana disappears ('Finished')

aspectRatio  gobananas : 1.333  bananarchy:  1.25
resolution       1024x768          1280x1024
FOV              60:46.82          60:49.58

I think we are recording enough information about the virtual world to know what we are looking at.
Likely suspects for figuring out what the subject sees:
VROBJECT_HEADING, especially for avatar (or VROBJECT_HDR for PandaEPL_defaultCamera - seem to be
                                         the same thing, but with a couple of extra zeros)
                                         always says LVecBase3f before it
VROBJECT_POS for avatar
What are Panda's units for distance? speed?

I think we can use the data in the log.txt file to feed back into Panda, and then record using
base.movie(). Probably we can add the eye position data and the spike/LFP data and do everything 
in Panda.

Was Kiril using any of the eye data or just logging it? What else was he pulling from the other
computer and why?

Tests are becoming quite problematic. Starting to require doing stuff in environment.
How to get around this?

Panda3d
Point3 Class comes from Panda3d:
A three-component point in space (as opposed to a vector, which represents a direction and a distance).
(float x, float y, float z)
myNodePath.setHpr([h],[p],[r])
myNodePath.setH([h]) heading: right, left (rotate around z axis)
myNodePath.setP([p]) pitch: climb, dive (rotate around x axis)
myNodePath.setR([r]) roll: cartwheels  (rotate around y axis)

More attributes to investigate:
DepthOffsetAttrib: Causes the Z-buffer to treat the object as if it were closer or farther
DeptTestAttrib: Alters teh way the Z-buffer affects the model.


What happens when you hit this object?
self.myModel.setCollisionCallback(MovingObject.chooseme)
chooseme can be:
MovingObject.handleRepelCollision # don't let colliding objects to into one another
MovingObject.handleSlideCollision # colliding objects slide along each other

if this is an object you care about the collision:
make a method:
self.myModel.collideMe
where:
def collideMe(self, collisionInfoList):
allows you to use this:
collisionInfoList[0].getInto().getIdentifier()
to get the id of what you collided with.

# 5.2 - fully trained                                                                                         
# 3.1   fullTurningSpeed = 0                                                                                  
# >= 3  fullForwardSpeed = 2.8                                                                                
# < 3   fullForwardSpeed = 0                                                                                  
# >= 2  fullTurningSpeed = 55                                                                                 
# < 2   fullTurningSpeed = 200     

Pandaepl has a state dictionary, which is written to disk. This is to save the
state between runs of the experiment, in case the subject doesn't finish the
experiment, we know where he/she left off. I don't think this is necessary for
us, but may want to implement it later.

I don't know what Pandaepl is doing, but this behavior is bizarre:
if I initiate two variables with the same key in the config dictionary:
x = config['x_start']
y = config['x_start']
this somehow links x and y, so that if I now change x, y will also change. WTF?

Globals:
LogException = <class 'pandaepl.Exceptions.LogException'>
Log = pandaepl.Log.Log
TempObject = pandaepl.TempObject.TempObject
Point2 = <type 'libpanda.LPoint2f'>
Camera = pandaepl.Camera.Camera
Point4 = <type 'libpanda.LPoint4f'>
IdentifierException = <class 'pandaepl.Exceptions.IdentifierException'>
timedCall = <function timedCall at 0x0240F7F0>
MovingObject = pandaepl.MovingObject.MovingObject
PandaEplException = <class 'pandaepl.Exceptions.PandaEplException'>
eegException = <class 'pandaepl.Exceptions.eegException'>
SoundException = <class 'pandaepl.Exceptions.SoundException'>
ExpFog = pandaepl.ExpFog.ExpFog
LinearFog = pandaepl.LinearFog.LinearFog
SessionException = <class 'pandaepl.Exceptions.SessionException'>
microtime = <function microtime at 0x0240F770>
VLQ = pandaepl.VideoLogQueue.VideoLogQueue
mstime = <function mstime at 0x0240F7B0>
optCmd = [window-type none auto-flip 0 win-size 800 600 fullscreen 0 show-frame-rate-meter 0 framebuffer-multisample 1]
Instructions = pandaepl.Instructions.Instructions
SimpleSound = pandaepl.SimpleSound.SimpleSound
Task = pandaepl.Task.Task
timestamp = (1381786796040L, 1L)
VBase3 = <type 'libpanda.LVecBase3f'>
VBase2 = <type 'libpanda.LVecBase2f'>
VBase4 = <type 'libpanda.LVecBase4f'>
direct = <module 'direct' from 'C:\Panda3D-1.8.1\direct\__init__.pyc'>
PointLight = pandaepl.PointLight.PointLight
Avatar = pandaepl.Avatar.Avatar
returnVal = [window-type none auto-flip 0 win-size 800 600 fullscreen 0 show-frame-rate-meter 0 framebuffer-multisample 1]
DirectionalLight = pandaepl.DirectionalLight.DirectionalLight
Model = pandaepl.Model.Model
Options = pandaepl.Options.Options
ConfLoadException = <class 'pandaepl.Exceptions.ConfLoadException'>
MainLoopException = <class 'pandaepl.Exceptions.MainLoopException'>
Text = pandaepl.Text.Text
Image = pandaepl.Image.Image
AmbientLight = pandaepl.AmbientLight.AmbientLight
Vr = pandaepl.Vr.Vr
Point3 = <type 'libpanda.LPoint3f'>
Vec2 = <type 'libpanda.LVector2f'>
Vec3 = <type 'libpanda.LVector3f'>
Conf = pandaepl.Conf.Conf
Experiment = pandaepl.Experiment.Experiment
SpotLight = pandaepl.SpotLight.SpotLight
LogQueue = pandaepl.LogQueue.LogQueue
